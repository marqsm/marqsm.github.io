<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Hash | Code, Cook, Sleep, repeat.]]></title>
  <link href="http://marqsm.github.io/blog/categories/hash/atom.xml" rel="self"/>
  <link href="http://marqsm.github.io/"/>
  <updated>2014-08-13T19:36:54-04:00</updated>
  <id>http://marqsm.github.io/</id>
  <author>
    <name><![CDATA[Marcus Malka]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Hash Extension Attack]]></title>
    <link href="http://marqsm.github.io/blog/2014/08/06/hash-extension-attack/"/>
    <updated>2014-08-06T17:43:01-04:00</updated>
    <id>http://marqsm.github.io/blog/2014/08/06/hash-extension-attack</id>
    <content type="html"><![CDATA[<hr />

<h2>Hash extension attack</h2>

<p>We had <a href="https://filippo.io/">Filippo Valsorda</a> hold a small presentation at <a href="http://www.hackerschool.com">Hacker School</a> today. The topic has how to exploit a hash extension vulnerability.</p>

<p>Problem lies in a combination of how hash-functions work, and unsafe ways of transmitting an API-secret in a request. The example-case was VIMEO&rsquo;s old API that had this vulnerability some years ago (nowdays the vulnerability is fixed).</p>

<h3>About MD5-hashes</h3>

<p><a href="http://en.wikipedia.org/wiki/MD5">MD5 hashes</a>  can&rsquo;t be reversed, it&rsquo;s a one-way functions.</p>

<p>This means  checking equality a server checks hashes a string and compares it with the received hashed string. The actual passwords are never compared, just the hashes.For ex. a naive hashed password check would mean taking a password from the database and comparing it with the hashed password from client.</p>

<p>MD5 hashses are nearly unique - accidental collisions are extremely rare, but a <a href="http://en.wikipedia.org/wiki/Collision_attack">collision attack</a> is possible. It&rsquo;s an iterative hash function, which means hashes are created by combining 512-bit (=64 byte) chunks of the input the the hash seed (which is predefined in MD5 spec). The hash is created only based on the input, so the next seed is formed from the created hash etc. This means the hash has to be extensible.</p>

<h3>The vulnerability</h3>

<p>The extensibility is built so, that there is no secret component. This means if someone captures the hash, they can extend it. This is important.</p>

<p>In this case, the hashed signature string was created by concatenating secret and key-value pairs alphabetically, md5-hashing that string, and adding it as api_sig value to the request. So (in this request) naive pseudocode representation of the request could be:
<code>
method: vimeo.test.login
api_key: e1df59512d6e136e5ba0936e8ac273cb
api_sig: hash_md5(api_secret + "api_key" + api_key + "method" + method)
</code>
So the hash would be created from string
<code>
sec12345api_keye1df59512d6e136e5ba0936e8ac273cbmethodvimeo.test.login
</code></p>

<p>This had two design flaws:
- The secret was prepended to the string that was hashed
- All the other components (except the secret) is passed in plaintext in the request</p>

<p>If the attacker captures a request (eg. by doing a <a href="http://en.wikipedia.org/wiki/Man-in-the-middle_attack">man-in-the-middle-attack</a>), changes the content, extends the signature hash to match the new request content, she can successfully pretend to be the original user and run any command she wishes (presuming it&rsquo;s allowed for the original user).</p>

<p>Example of the forged request:
<code>
a: api_keye1df59512d6e136e5ba0936e8ac273cbmethodvimeo.test.login\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xe8\x02\x00\x00\x00\x00\x00\x00
video_id: 1337
favorite: 1
method: vimeo.videos.setFavorite
api_key: e1df59512d6e136e5ba0936e8ac273cb
api_sig: caf3d8384c2fbf2917c2b78dcf8ac588
</code>
<code>api_sig</code> is formed by hashing the whole new request key-value pairs in alphabetical order. An important part is the <code>a</code>-attribute, which contains the old request + padding required by MD5, which can be considered just an implementation detail. The main idea is that the new signature can be constructed from the old request and new added key-value pairs, which may be completely different from the original ones.</p>

<h3>Further reading</h3>

<p>A more complete article about hash-extension attacks
<a href="https://blog.skullsecurity.org/2012/everything-you-need-to-know-about-hash-length-extension-attacks">https://blog.skullsecurity.org/2012/everything-you-need-to-know-about-hash-length-extension-attacks</a></p>

<p>A very thorough article about why and how to use salts &amp; hashes when storing passwords: <a href="http://www.codeproject.com/Articles/704865/Salted-Password-Hashing-Doing-it-Right">http://www.codeproject.com/Articles/704865/Salted-Password-Hashing-Doing-it-Right</a></p>
]]></content>
  </entry>
  
</feed>
